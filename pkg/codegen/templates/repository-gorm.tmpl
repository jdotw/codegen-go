type repository struct {
	ctx context.Context
	db  *gorm.DB
}

func NewGormRepository(ctx context.Context, connString string, tracer opentracing.Tracer, logger log.Factory) (Repository, error) {
	var r Repository
	{
		db, err := gorm.Open(postgres.Open(connString), &gorm.Config{})
		if err != nil {
			logger.For(ctx).Fatal("Failed to open db", zap.Error(err))
		}

		db.Use(gormopentracing.New(gormopentracing.WithTracer(tracer)))

		err = db.AutoMigrate(&api.DirectDebitFacility{})
		if err != nil {
			logger.For(ctx).Fatal("Failed to migrate db", zap.Error(err))
		}

		r = &repository{ctx: ctx, db: db}
	}

	return r, nil
}


{{range .Ops}}
{{$hasParams := .RequiresParamObject -}}
{{$pathParams := .PathParams -}}
{{$opid := .OperationId -}}
{{$tag := .Tag -}}
  func (p *repository) {{$opid}}(ctx context.Context{{range .PathParams -}}, {{.ParamName}} string{{end}}{{if .HasBody}}, v *{{$tag}}{{end}}) (*{{$tag}}, error) {
    {{if isCreate .}}tx := p.db.WithContext(ctx).Create(&v)
	  return tx.Error
    {{end}}
    {{if isGet .}}
	  var v {{$tag}}
	  tx := p.db.WithContext(ctx).First(&v, "id = ?", id)
	  if tx.Error == gorm.ErrRecordNotFound {
		  return nil, recorderrors.ErrNotFound
  	}
  	return &v, tx.Error
    {{end}}
    {{if isUpdate .}}
  	tx := p.db.WithContext(ctx).Model(&{{$tag}}{}).Where("id = ?", id).UpdateColumns(v)
	  if tx.RowsAffected == 0 {
		  return nil, recorderrors.ErrNotFound
	  }
	  v.ID = &id
  	return v, tx.Error
    {{end}}
    {{if isOther .}}
    // TODO: Unable to generate code for this Operation
    {{end}}
  }
{{end}}

